/*!
 * Copyright 2014 Digital Services, University of Cambridge Licensed
 * under the Educational Community License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-tickets');

var Ticket = require('../model').Ticket;
var TicketsConstants = require('../constants').TicketsConstants;
var PublicationTicket = require('../model').PublicationTicket;

/**
 * Creates a new ticket
 *
 * @param  {String}     ticketId                    The ticket ID
 * @param  {String}     externalId                  The external ID of the ticket
 * @param  {String}     publicationId               The ID of the publication
 * @param  {String}     tenantAlias                 The alias of the tenant where the ticket was created in
 * @param  {String}     createdBy                   The ID of the user that created the ticket
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                The thrown error, if any
 * @param  {Ticket}     callback.ticket             The created ticket
 */
var createTicket = module.exports.createTicket = function(ticketId, externalId, publicationId, tenantAlias, createdBy, callback) {

    // Check if the publication hasn't already been linked to a ticket
    getTicketByPublicationId(publicationId, function(err, result) {
        if (err) {
            return callback(err);
        }

        if (result) {
            log().error({'code': 400, 'msg': 'The publication has already been linked to a ticket'}, 'Error while creating ticket for publication');
            return callback({'code': 400, 'msg': 'The publication has already been linked to a ticket'});
        }

        // Collection of Cassandra queries
        var queries = [];

        // Construct a query that creates a record of a publication linked to a ticket
        var parameters = {'ticketId': ticketId};
        queries.push(Cassandra.constructUpsertCQL('TicketsByPublication', 'publicationId', publicationId, parameters));

        // Construct a query that creates a new ticket
        parameters = {
            'externalId': externalId,
            'publicationId': publicationId,
            'tenantAlias': tenantAlias,
            'createdBy': createdBy,
            'status': TicketsConstants.statusses.NEW
        };
        parameters = _.extend(parameters, {'created': Date.now(), 'lastModified': Date.now()});
        queries.push(Cassandra.constructUpsertCQL('Tickets', 'ticketId', ticketId, parameters));

        // Send the queries off to cassandra
        Cassandra.runBatchQuery(queries, function(err) {
            if (err) {
                log().error({'err': err}, 'Error while creating ticket');
                return callback(err);
            }

            // Return the created ticket
            return callback(null, _.extend(parameters, {'ticketId': ticketId}));
        });
    });
};

/**
 * Deletes a ticket
 *
 * @param  {String}     ticketId            The id of the ticket that needs to be deleted
 * @param  {String}     publicationId       The id of the linked publication
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 */
var deleteTicket = module.exports.deleteTicket = function(ticketId, publicationId, callback) {
    var queries = [];

    // Delete the ticket from the 'tickets' table
    queries.push({'query': 'DELETE FROM "Tickets" WHERE "ticketId" = ?', 'parameters': [ticketId]});

    // Make sure the corresponding doesn't have a linked ticket anymore
    queries.push({'query': 'DELETE FROM "TicketsByPublication" WHERE "publicationId" = ?', 'parameters': [publicationId]});

    // Send the queries off to cassandra
    Cassandra.runBatchQuery(queries, function(err) {
        if (err) {
            log().error({'err': err, 'ticketId': ticketId}, 'Error whilst deleting ticket');
            return callback(err);
        }

        return callback();
    });
};

/**
 * Returns a ticket
 *
 * @param  {String}     ticketId            The id of the ticket that needs to be returned
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     The requested ticket
 */
var getTicket = module.exports.getTicket = function(ticketId, callback) {
    Cassandra.runQuery('SELECT * FROM "Tickets" WHERE "ticketId" = ?', [ticketId], function(err, rows) {
        if (err) {
            log().error({'code': err.code, 'ticketId': ticketId, 'msg': err.msg}, 'Error while requesting ticket');
            return callback(err);
        }

        // Return an error if the requested ticket was not found
        if (_.isEmpty(rows)) {
            return callback({'code': 404, 'msg': 'The requested ticket was not found'});
        }

        var ticket = _rowToTicket(rows[0]);
        return callback(null, ticket);
    });
};

/**
 * Returns a collection of tickets
 *
 * @param  {String[]}   ticketIds           Collection of ticket ID's
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket[]}   callback.tickets    Array containing a ticket object for each available ticket for the user
 */
var getTickets = module.exports.getTickets = function(ticketIds, callback) {
    Cassandra.runQuery('SELECT * FROM "Tickets" WHERE "ticketId" IN (?)', [ticketIds], function(err, rows) {
        if (err) {
            log().error({'code': err.code, 'msg': err.msg}, 'Error while requesting tickets');
            return callback(err);
        }

        // Return an error if no tickets were found
        if (_.isEmpty(rows)) {
            return callback({'code': 404, 'msg': 'The requested tickets were not found'});
        }

        var tickets = _rowsToTickets(rows);
        return callback(null, tickets);
    });
};

/**
 * Check if a publication is linked to a ticket
 *
 * @param  {String}     publicationId       The publication ID
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containg error code and error message
 * @param  {Ticket}     callback.ticket     The ticket that corresponds with the publication (if any)
 */
var getTicketByPublicationId = module.exports.getTicketByPublicationId = function(publicationId, callback) {
    Cassandra.runQuery('SELECT * FROM "TicketsByPublication" WHERE "publicationId" = ?', [publicationId], function(err, rows) {
        if (err) {
            log().error({'code': err.code, 'msg': err.msg}, 'Error while checking publication ticket');
            return callback(err);
        }

        // Return an empty result if the ticket was not found
        if (_.isEmpty(rows)) {
            return callback();
        }

        // Return the ticket
        var publicationTicket = _rowToPublicationTicket(rows[0]);
        getTicket(publicationTicket.ticketId, function(err, ticket) {
            if (err) {
                return callback(err);
            }

            return callback(null, ticket);
        });
    });
};

/**
 * Adds a corresponding ticket to each publication of a set of publications
 *
 * @param  {String[]}       publicationIds      Collection of publication ID's
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containg error code and error message
 * @param  {Ticket[]}       callback.tickets    The tickets that correspond with the publication ID's (if any)
 */
var getTicketsByPublicationIds = module.exports.getTicketsByPublicationIds = function(publicationIds, callback) {
    Cassandra.runQuery('SELECT * FROM "TicketsByPublication" WHERE "publicationId" IN (?)', [publicationIds], function(err, rows) {
        if (err) {
            log().error({'code': err.code, 'msg': err.msg}, 'Error while checking publication ticket');
            return callback(err);
        }

        // Return an error if no matching tickets were found
        if (_.isEmpty(rows)) {
            return callback({'code': 404, 'msg': 'No matching tickets found for any of the publication ID\'s'});
        }

        var ticketIds = _rowsToPublicationTickets(rows);
        ticketIds = _.map(_rowsToPublicationTickets(rows), function(row) { return row.ticketId; });

        // Return an error if no matching tickets were found
        if (_.isEmpty(ticketIds)) {
            return callback({'code': 404, 'msg': 'No matching tickets found for any of the publication ID\'s'});
        }

        // Retrieve all the tickets by their ticket ID
        getTickets(ticketIds, function(err, tickets) {
            if (err) {
                return callback({'code': 404, 'msg': 'No matching tickets found for any of the publication ID\'s'});
            }

            return callback(null, tickets);
        });
    });
};

/**
 * Return the current tickets counter value
 *
 * @param  {String}     tenantAlias             The alias of the tenant the ticket was created in
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Error object containing error code and error message
 * @param  {String}     callback.counterValue   The current counter value
 */
var getTicketsCounter = module.exports.getTicketsCounter = function(tenantAlias, callback) {

    // Run the Cassandra query that returns the current counter value
    Cassandra.runQuery('SELECT "value" FROM "TicketsCounter" WHERE "tenantAlias" = ?', [tenantAlias], function(err, rows) {
        if (err) {
            log().error(err);
            return callback(err);
        }

        if (_.isEmpty(rows)) {
            return callback(null, 0);
        }

        var row = Cassandra.rowToHash(rows[0]);
        var value = row.value;

        return callback(null, value);
    });
};

/**
 * Increase the tickets counter value
 *
 * @param  {String}     tenantAlias             The alias of the tenant the ticket was created in
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.er             Error object containing error code and error message
 * @param  {String}     callback.counterValue   The current counter value after update
 */
var increaseTicketsCounter = module.exports.increaseTicketsCounter = function(tenantAlias, callback) {
    Cassandra.runQuery('UPDATE "TicketsCounter" SET value = value + 1 WHERE "tenantAlias" = ?', [tenantAlias], function(err) {
        if (err) {
            log().error({'code': err.code, 'tenant': tenantAlias, 'msg': err.msg}, 'Error while increasing tickets counter');
            return callback(err);
        }

        return getTicketsCounter(tenantAlias, callback);
    });
};

/**
 * Update a ticket
 *
 * @param  {String}     ticketId            The id of the ticket that needs to be updated
 * @param  {Object}     opts                Object containing the updates for the ticket
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 */
var updateTicket = module.exports.updateTicket = function(ticketId, opts, callback) {

    // Construct the query
    var q = Cassandra.constructUpsertCQL('Tickets', 'ticketId', ticketId, opts, 'QUORUM');
    if (!q) {
        return callback({'code': 500, 'msg': 'Unable to store ticket fields'});
    }

    // Execute the Cassandra query
    Cassandra.runQuery(q.query, q.parameters, function(err) {
        if (err) {
            log().error({'code': err.code, 'ticket': ticketId, 'opts': opts, 'msg': err.msg}, 'Error while updating ticket');
            return callback(err);
        }
        return callback();
    });
};

/**
 * Converts a Cassandra row to a `PublicationTicket` object
 *
 * @param  {Row}                    row     The Cassandra row to convert
 * @return {PublicationTicket}              Object that represents a publication ticket
 * @api private
 */
var _rowToPublicationTicket = function(row) {
    var hash = Cassandra.rowToHash(row);
    return new PublicationTicket(hash.publicationId, hash.ticketId);
};

/**
 * Creates a collection of ticket ID's from a set of Cassandra rows
 *
 * @param  {Row[]}                  rows    A collection of Cassandra rows
 * @return {PublicationTicket[]}            A collection of converted publication ticket objects
 * @api private
 */
var _rowsToPublicationTickets = function(rows) {
    var tickets = [];
    _.each(rows, function(row) {
        var ticket = _rowToPublicationTicket(row);
        tickets.push(ticket);
    });
    return tickets;
};

/**
 * Creates a ticket object from a Cassandra row
 *
 * @param  {Row}        row     Cassandra Row
 * @return {Ticket}             Converted ticket object
 * @api private
 */
var _rowToTicket = function(row) {
    var hash = Cassandra.rowToHash(row);
    var ticket = new Ticket(hash.ticketId, hash.externalId, hash.tenantAlias, hash.publicationId, hash.createdBy, hash.created, hash.lastModified, hash.status);
    return ticket;
};

/**
 * Creates a collection of ticket objects from a set of Cassandra rows
 *
 * @param  {Row[]}      rows    A collection of Cassandra rows
 * @return {Ticket[]}           A collection of converted ticket objects
 * @api private
 */
var _rowsToTickets = function(rows) {
    var tickets = [];
    _.each(rows, function(row) {
        var ticket = _rowToTicket(row);
        tickets.push(ticket);
    });
    return tickets;
};
